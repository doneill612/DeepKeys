from mido import MidiFile, MidiTrack, Message
from music21 import converter
import glob
import numpy as np

"""
Retrieves the .mid files from a specified directory

path: the directory path
@:return the .mid files
"""
def get_songs(path):
    print("Fetching midis...")
    files = glob.glob("{}\*.mid*".format(path))
    songs = list()
    for file in files:
        mid = MidiFile(file)
        songs.append(mid)
    print("Done!")
    return songs

"""
PRIVATE FUNCTION
Returns the notes in a .mid file

midi: the .mid file
@:return the notes in a given .mid file
"""
def __get_notes_in_piece(midi):
    notes = list()

    time = float(0)
    previous = float(0)

    for msg in midi:
        time += msg.time
        if not msg.is_meta and msg.type == 'note_on':
            note = msg.bytes()
            note = note[1:3]
            note.append(time - previous)
            previous = time
            notes.append(note)

    return notes

"""
Concatenates all the notes from a set of .mid files into a single list object

midis: the .mid files to extract notes from
@:return all the notes in the supplied .mid file as a list
"""
def get_all_notes(midis):
    print("Getting notes...")
    notes = list()
    for midi in midis:
        curr_notes = __get_notes_in_piece(midi)
        if len(notes) == 0:
            notes = curr_notes
        else:
            notes += curr_notes
    print("Done!")
    return notes

"""
Scales note values and properties so they are in the range [0, 1]

notes: the notes to scale
@:return the time span of the longest note in the supplied data
"""
def scale_note_data(notes):
    times = list()

    for note in notes:
        note[0] = (note[0] - 24) / 88
        note[1] /= 127
        times.append(note[2])

    max_time = max(times)

    for note in notes: note[2] /= max_time

    return max_time

"""
Creates and saves a composition given a seed prediction

prediction: the seed prediction generated by the network
generation: naming parameter - what generation composition is it?
"""
def save_new_song(prediction, file_name):

    print("Saving raw song...")

    midi = MidiFile()
    track = MidiTrack()
    midi.tracks.append(track)

    for note in prediction:
        note = np.insert(note, 0, 147)
        _bytes = note.astype(int)
        message = Message.from_bytes(_bytes[0:3])
        time = int(note[3] / 0.001025)
        message.time = time
        track.append(message)

    path = 'output/{}.mid'.format(file_name)
    midi.save(path)

    print("Done!")
    return path

"""
Scales the audio of midi file at the supplied path by the factor 'scale'

path: midi location
scale: scale factor
"""
def scale_song(path, scale):

    print("Scaling song...")
    score = converter.parse(path)
    new_score = score.scaleOffsets(scale).scaleDurations(scale)
    new_score.write('midi', path)
    print("Done!")
